use anyhow::Result;
use clap::{Parser, Subcommand};
use tokio_stream::StreamExt;
use tonic::Request;

// Import the generated gRPC client
use crate::grpc::mos::{
    mos_client::MosClient, GetJointAnglesRequest, SetJointAnglesRequest, TaskRequest,
    TelemetryResponse,
};

mod grpc {
    // This module will contain the code generated by tonic-build
    pub mod mos;
}

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
#[command(propagate_version = true)]
struct Cli {
    #[arg(short, long, global = true, default_value = "http://[::1]:50052")]
    server_addr: String,

    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    /// Commands for task management
    Task {
        #[command(subcommand)]
        action: TaskAction,
    },
    /// Commands for telemetry
    Telemetry {
        #[command(subcommand)]
        action: TelemetryAction,
    },
    /// Commands for robot control
    Robot {
        #[command(subcommand)]
        action: RobotAction,
    },
}

#[derive(Subcommand, Debug)]
enum TaskAction {
    /// Schedule a new task
    Schedule {
        #[arg(short, long, default_value_t = 10)]
        priority: u32,
    },
}

#[derive(Subcommand, Debug)]
enum TelemetryAction {
    /// Stream telemetry data from the server
    Stream,
}

#[derive(Subcommand, Debug)]
enum RobotAction {
    /// Set target joint angles for the robot
    Set {
        /// A list of joint angles
        #[arg(required = true, num_args = 1..)]
        angles: Vec<f64>,
    },
    /// Get the current joint angles of the robot
    Get,
}

#[tokio::main]
async fn main() -> Result<()> {
    env_logger::init();
    let cli = Cli::parse();

    log::info!("Connecting to server at {}", cli.server_addr);
    let mut client = MosClient::connect(cli.server_addr.clone())
        .await
        .map_err(|e| anyhow::anyhow!("Failed to connect to server: {}", e))?;

    let _placeholder = TelemetryResponse {
        id: 0,
        success: false,
        message: "placeholder".to_string(),
    };

    match &cli.command {
        Commands::Task { action } => match action {
            TaskAction::Schedule { priority } => {
                handle_schedule_task(&mut client, *priority).await?;
            }
        },
        Commands::Telemetry { action } => match action {
            TelemetryAction::Stream => {
                handle_stream_telemetry(&mut client).await?;
            }
        },
        Commands::Robot { action } => match action {
            RobotAction::Set { angles } => {
                handle_set_joint_angles(&mut client, angles).await?;
            }
            RobotAction::Get => {
                handle_get_joint_angles(&mut client).await?;
            }
        },
    }

    Ok(())
}

async fn handle_schedule_task(
    client: &mut MosClient<tonic::transport::Channel>,
    priority: u32,
) -> Result<()> {
    let request = Request::new(TaskRequest {
        priority,
        ..Default::default()
    });

    log::info!("Sending schedule task request with priority {}", priority);
    let response = client.schedule_task(request).await?;
    let task_response = response.into_inner();

    println!("Successfully scheduled task with ID: {}", task_response.id);
    Ok(())
}

async fn handle_stream_telemetry(client: &mut MosClient<tonic::transport::Channel>) -> Result<()> {
    let (tx, rx) = tokio::sync::mpsc::channel(1);
    drop(tx);

    let request = Request::new(tokio_stream::wrappers::ReceiverStream::new(rx));

    log::info!("Opening telemetry stream...");
    let mut stream = client.stream_telemetry(request).await?.into_inner();

    println!("Receiving telemetry data (Press Ctrl+C to stop):");
    while let Some(item) = stream.next().await {
        match item {
            Ok(telemetry) => {
                println!(
                    "[{}] Source: {}, Value: {:.4}, Timestamp: {}",
                    chrono::Utc::now().to_rfc3339(),
                    telemetry.source,
                    telemetry.value,
                    telemetry.timestamp
                );
            }
            Err(e) => {
                eprintln!("Error receiving telemetry data: {}", e);
                break;
            }
        }
    }
    Ok(())
}

async fn handle_set_joint_angles(
    client: &mut MosClient<tonic::transport::Channel>,
    angles: &[f64],
) -> Result<()> {
    let request = Request::new(SetJointAnglesRequest { angles: angles.to_vec() });

    log::info!("Sending set joint angles request with angles: {:?}", angles);
    let response = client.set_joint_angles(request).await?;
    let command_response = response.into_inner();

    if command_response.success {
        println!("Successfully set joint angles: {}", command_response.message);
    } else {
        eprintln!("Failed to set joint angles: {}", command_response.message);
    }
    Ok(())
}

async fn handle_get_joint_angles(client: &mut MosClient<tonic::transport::Channel>) -> Result<()> {
    let request = Request::new(GetJointAnglesRequest {});

    log::info!("Sending get joint angles request");
    let response = client.get_joint_angles(request).await?;
    let get_response = response.into_inner();

    println!("Current joint angles: {:?}", get_response.angles);
    Ok(())
}