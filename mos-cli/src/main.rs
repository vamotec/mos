use clap::{Parser, Subcommand};
use anyhow::Result;
use tonic::Request;
use tokio_stream::StreamExt;

// Import the generated gRPC client
use crate::grpc::mos::{mos_client::MosClient, TaskRequest, TelemetryResponse};

mod grpc {
    // This module will contain the code generated by tonic-build
    pub mod mos;
}

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
#[command(propagate_version = true)]
struct Cli {
    #[arg(short, long, global = true, default_value = "http://[::1]:50051")]
    server_addr: String,

    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    /// Commands for task management
    Task {
        #[command(subcommand)]
        action: TaskAction,
    },
    /// Commands for telemetry
    Telemetry {
        #[command(subcommand)]
        action: TelemetryAction,
    },
}

#[derive(Subcommand, Debug)]
enum TaskAction {
    /// Schedule a new task
    Schedule {
        #[arg(short, long, default_value_t = 10)]
        priority: u32,
    },
}

#[derive(Subcommand, Debug)]
enum TelemetryAction {
    /// Stream telemetry data from the server
    Stream,
}

#[tokio::main]
async fn main() -> Result<()> {
    env_logger::init();
    let cli = Cli::parse();

    log::info!("Connecting to server at {}", cli.server_addr);
    let mut client = MosClient::connect(cli.server_addr.clone()).await
        .map_err(|e| anyhow::anyhow!("Failed to connect to server: {}", e))?;

    // ✅ 创建一个 TelemetryResponse 占位实例
    let _placeholder = TelemetryResponse {
        id: 0,
        success: false,
        message: "placeholder".to_string(),
    };

    match &cli.command {
        Commands::Task { action } => match action {
            TaskAction::Schedule { priority } => {
                handle_schedule_task(&mut client, *priority).await?;
            }
        },
        Commands::Telemetry { action } => match action {
            TelemetryAction::Stream => {
                handle_stream_telemetry(&mut client).await?;
            }
        },
    }

    Ok(())
}

async fn handle_schedule_task(client: &mut MosClient<tonic::transport::Channel>, priority: u32) -> Result<()> {
    // With the `id` field being optional, we can omit it. 
    // It will default to 0, signaling the server to assign a new ID.
    let request = Request::new(TaskRequest { priority, ..Default::default() });

    log::info!("Sending schedule task request with priority {}", priority);
    let response = client.schedule_task(request).await?;
    let task_response = response.into_inner();

    println!("Successfully scheduled task with ID: {}", task_response.id);
    Ok(())
}

async fn handle_stream_telemetry(client: &mut MosClient<tonic::transport::Channel>) -> Result<()> {
    // The gRPC call is a bidirectional stream. We must send a stream of the correct
    // message type, even if we don't intend to send any messages.
    let (tx, rx) = tokio::sync::mpsc::channel(1);

    // By dropping the sender immediately, the stream will close after being sent,
    // which is fine for now as we are only interested in the server's responses.
    drop(tx);

    let request = Request::new(tokio_stream::wrappers::ReceiverStream::new(rx));

    log::info!("Opening telemetry stream...");
    let mut stream = client.stream_telemetry(request).await?.into_inner();

    println!("Receiving telemetry data (Press Ctrl+C to stop):");
    while let Some(item) = stream.next().await {
        match item {
            Ok(telemetry) => {
                println!(
                    "[{}] Source: {}, Value: {:.4}, Timestamp: {}",
                    chrono::Utc::now().to_rfc3339(),
                    telemetry.source,
                    telemetry.value,
                    telemetry.timestamp
                );
            }
            Err(e) => {
                eprintln!("Error receiving telemetry data: {}", e);
                break;
            }
        }
    }
    Ok(())
}